var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

;(function (root, factory) {
  /* istanbul ignore next */
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
    module.exports = factory();
  } else {
    root.Smartcar = factory();
  }
})(this, function () {
  'use strict';

  /* eslint-env node */

  var Smartcar = function () {
    /**
     * @callback OnComplete
     * @param {?Error} error - something went wrong in the authorization flow; this
     * normally indicates that the user denied access to your application or does not
     * have a connected vehicle
     * @param {String} code - the authorization code to be exchanged from a
     * backend sever for an access token
     * @param {Object} [state] - contains state if it was set on the initial
     * authorization request
     */

    /**
     * Initializes Smartcar class.
     *
     * @constructor
     * @param {Object} options - the SDK configuration object
     * @param {String} options.clientId - the application's client id
     * @param {String} options.redirectUri - the registered redirect uri of the
     * application
     * @param {String[]} [options.scope] - requested permission scopes
     * @param {OnComplete} [options.onComplete] - called on completion of auth flow
     * @param {Boolean} [options.testMode=false] - launch the Smartcar auth flow in test mode
     */
    function Smartcar(options) {
      var _this = this;

      _classCallCheck(this, Smartcar);

      // ensure options are well formed
      Smartcar._validateConstructorOptions(options);

      this.clientId = options.clientId;
      this.redirectUri = options.redirectUri;
      this.scope = options.scope;
      this.onComplete = options.onComplete;
      this.mode = options.testMode === true ? 'test' : 'live';
      this.responseType = 'code';

      // handler
      this.messageHandler = function (event) {
        // bail if message from unexpected source
        if (!_this.redirectUri.startsWith(event.origin)) {
          return;
        }

        var message = event.data || {};
        // bail if `message.name` is not `SmartcarAuthMessage`
        // this prevents attempting to handle messages intended for others
        if (message.name !== 'SmartcarAuthMessage') {
          return;
        }

        // if onComplete not specified do nothing, assume developer is conveying
        // completion information from backend server receiving redirect to front
        // end (not using onComplete)
        if (_this.onComplete) {
          // if auth errored generate appropriate error else null
          var generateError = function generateError(error, description) {
            if (!error) {
              return null;
            }

            return error === 'access_denied' ? new Smartcar.AccessDenied(description) : new Error('Unexpected error: ' + error + ' - ' + description);
          };
          var err = generateError(message.error, message.errorDescription);

          /**
           * Call `onComplete` with parameters even if developer is not using
           * a Smartcar-hosted redirect. Regardless of if they are using a
           * Smartcar-hosted redirect they may still want `onComplete` to do
           * something with message.
           *
           * If empty onComplete is passed, parameters will be harmlessly ignored.
           *
           * If a developer chooses to pass an `onComplete` expecting these
           * parameters they must also handle populating the corresponding query
           * parameters in their redirect uri.
           */
          _this.onComplete(err, message.code, message.state);
        }
      };

      // add handler for postMessage event on completion of auth flow
      window.addEventListener('message', this.messageHandler);
    }

    /**
     * Validate options passed to Smartcar constructor.
     *
     * See constructor documentation for enumeration of options properties.
     *
     * @private
     * @param {Object} options - the SDK configuration object
     */


    _createClass(Smartcar, [{
      key: 'getAuthUrl',


      /**
       * Generates Smartcar OAuth URL.
       *
       * @param {Object} options - the link configuration object
       * @param {String} [options.state] - arbitrary parameter passed to redirect uri
       * @param {Boolean} [options.forcePrompt=false] - force permission approval
       * screen to show on every authentication, even if the user has previously
       * consented to the exact scope of permission
       * @return {String} generated OAuth link
       */
      value: function getAuthUrl(options) {
        options = options || {};

        var link = '';
        link += 'https://connect.smartcar.com/oauth/authorize';
        link += '?response_type=' + this.responseType;
        link += '&client_id=' + this.clientId;
        link += '&redirect_uri=' + encodeURIComponent(this.redirectUri);

        // map forcePrompt to approvalPrompt, two options: 'force' and 'auto'
        var forcePrompt = options.forcePrompt || false;
        link += '&approval_prompt=' + (forcePrompt ? 'force' : 'auto');

        // If scope is not specified, Smartcar will default to requesting all scopes
        // from the user
        if (this.scope) {
          link += '&scope=' + encodeURIComponent(this.scope.join(' '));
        }

        link += '&mode=' + this.mode;

        if (options.state) {
          link += '&state=' + options.state;
        }

        return link;
      }

      /**
       * Launches the OAuth dialog flow.
       *
       * @param {Object} options - the link configuration object
       * @param {String} [options.state] - arbitrary parameter passed to redirect uri
       * @param {Boolean} [options.forcePrompt=false] - force permission approval
       * screen to show on every authentication, even if the user has previously
       * consented to the exact scope of permission
       */

    }, {
      key: 'openDialog',
      value: function openDialog(options) {
        var href = this.getAuthUrl(options);
        var windowOptions = Smartcar._getWindowOptions();
        window.open(href, 'Connect your car', windowOptions);
      }

      /**
       * Adds an on-click event listener to the element with the provided id.
       *
       * On-click event calls openDialog when the specified element is clicked.
       *
       * @param {Object} options - clickHandler configuration object
       * @param {String} options.id - id of the element to add click handler to
       * @param {String} [options.state] - arbitrary parameter passed to redirect uri
       * @param {Boolean} [options.forcePrompt] - force permission approval screen to
       * show on every authentication, even if the user has previously consented
       * to the exact scope of permission
       */

    }, {
      key: 'addClickHandler',
      value: function addClickHandler(options) {
        var _this2 = this;

        var id = options.id;
        var dialogOptions = {
          state: options.state,
          forcePrompt: options.forcePrompt
        };

        var element = document.getElementById(id);
        if (!element) {
          throw new Error('Could not add click handler: element with id \'' + id + '\' was not found.');
        }

        element.addEventListener('click', function () {
          _this2.openDialog(dialogOptions);
          // this is equivalent to calling:
          // event.preventDefault();
          // event.stopPropogation();
          return false;
        });
      }
    }], [{
      key: '_validateConstructorOptions',
      value: function _validateConstructorOptions(options) {
        // allow only one instance of Smartcar
        if (Smartcar._hasBeenInstantiated) {
          throw new Error('Smartcar has already been instantiated in the window. Only one' + ' instance of Smartcar can be defined.');
        } else {
          Smartcar._hasBeenInstantiated = true;
        }

        if (!options.clientId) {
          throw new TypeError('A client ID option must be provided');
        }

        if (!options.redirectUri) {
          throw new TypeError('A redirect URI option must be provided');
        }

        if (options.redirectUri.startsWith('https://javascript-sdk.smartcar.com')) {
          // require onComplete method with at least two parameters (error & code)
          // when hosting on Smartcar CDN
          if (!options.onComplete || options.onComplete.length < 2) {
            throw new Error("When using Smartcar's CDN redirect an onComplete function with at" + ' least 2 parameters (error & code) is required to handle' + ' completion of authorization flow');
          }
        }
      }

      /**
       * Calculate popup window size and position based on current window settings.
       *
       * @private
       * @return {String} a string of window settings
       */

    }, {
      key: '_getWindowOptions',
      value: function _getWindowOptions() {
        // Sets default popup window size
        var windowSettings = {
          width: 430,
          height: 500
        };

        var width = (window.outerWidth - windowSettings.width) / 2;
        var height = (window.outerHeight - windowSettings.height) / 8;

        var options = '';
        options += 'top=' + (window.screenY + height) + ',';
        options += 'left=' + (window.screenX + width) + ',';
        options += 'width=' + windowSettings.width + ',';
        options += 'height=' + windowSettings.height + ',';

        return options;
      }
    }]);

    return Smartcar;
  }();

  /**
   * Access denied error returned by authorization flow.
   *
   * @extends Error
   */


  Smartcar.AccessDenied = function (_Error) {
    _inherits(_class, _Error);

    /**
     * @param {String} message - detailed error description
     */
    function _class(message) {
      _classCallCheck(this, _class);

      var _this3 = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, message));

      _this3.name = 'AccessDenied';
      return _this3;
    }

    return _class;
  }(Error);

  return Smartcar;
});